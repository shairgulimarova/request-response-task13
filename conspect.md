## HTTP ЗАПРОСЫ. 
Это протокол, где описсывается взаимодействие двух компьютеров: клиента и сервера. Клиент делает запрос -REGUEST, а сервер отвечает на запрос - RESPONSE. 

## Сообщения Request & Response состоят из трех частей: стартовая строка, заголовок и тело. 

## стартовая строка 
METHOD URI HTTP/VERSION

## заголовок 
Это имя и значение, разделенные двоеточием. Здесь передается различная информация: название и версия браузера, адрес с которого пришел клиент и тд. 

## Тело 
Здесь содержиться содержимое загружаемых на сервер файлов - если это REQUEST. Как правило в запросе тело сообщерния отсутствует. 
Здесь содержиться HTML страница - если это RESPONSE.

## Пример HTTP взаимодействия. 

Request:
GET /index.php HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0 (X11; U; Linux i686; ru; rv:1.9b5) Gecko/2008050509 Firefox/3.0b5
Accept: text/html
Connection: close

Первая строка — это строка запроса, остальные — заголовки; тело сообщения отсутствует

Response:
HTTP/1.0 200 OK
Server: nginx/0.6.31
Content-Language: ru
Content-Type: text/html; charset=utf-8
Content-Length: 1234
Connection: close

... САМА HTML-СТРАНИЦА ...


## Ресурсы и методы 
URI - Uniform Resource Identifier -Единообразный Идернтификатор Ресурсов. Ресурс - файл на сервере. 

1- Тип http запрос(http метод) указывает какое действие нужно сделать с ресурсом. 
2- В 90-х, изначально предпологалось, что с ресурсом можно делать только одно: получить.
3- Сейчас с ресурсом можно делать многое : получить, редактировать, отправить, удалять и тд. ПОЭТОМУ БЫЛИ ПРИДУМАНЫ ДРУГИЕ МЕТОДЫ: 
- GET - получение ресурса 
- POST - создание ресурса 
- DELETE - удаление ресурса 
- PUT - обновление ресурса 

## Что такое REST?
- Название группы принципов построения веб-приложения.
- Охватывает более широкую область чем HTTP 
- Можно применять в других сетях с другими протоколами. 
- Основан в 2000-м году Роем Филдингом - один из разработчиков HTTP. 
- Дает возможность создавать стандартизированные и более красивыце веб-приложения. 



## Асинхроннное програмирование 

const users = loadUsers(); 
 doAnother(); 

Такой код работает синхронно, т.е функция doAnother() не будет ждать переменную юзерс. SetTimeOut можно установить время через сколько чтобы выполнился второй код. Но это не удобно. 

 ## AJAX -> async JS XML 

document.getElementById("get-data").addEventListener("click", loadData);


function loadData(){
    1-нужно сделать http запрос, чтобы получить данные и на интерфейсе вывести эти данные. 
    2-для этого воспользуемся классом XHR - XML HTTP REQUEST 

     объявляем переменную, где берем инстанс XHR
     const xhr = new XMLHttpRequest(); 
    <- Это встроенная JS класс, которая позволяет делать получать делать эти запросы 
    У него есть методы: open - делает запросы Есть разные виды запросов: get - чтобы получить, post - чтобы отправить что-то, put-редактировать, delete etc. which is used according to purposes.  
    У метода должны быть три параметра: 1-одно из списка на 19-20 строчке, 2-url adress 3-true (хотим, чтобы JS работал асинхронно, а если пишем false, работает как обычный JS т.е синхронно)
    xhr. open("GET", "db.txt", true); // в этом случае название файла вместо url 

     У запросов разные стадии: инициализации, обработки итд. 
     у него есть метод onload, когда будет загружен онлоад запускаем функцию

    xhr.onload = function(){
        Кодгда делаем запросы очень важны проверки. 200 - page is faund/ apposite of 404 
         if(this.status ===200){
             console.log(this.response)
         } else {
     alert ("error")
     }
     }
      
      Есть метод, с помощью которого узнаем состояние прогресса 
      xhr.onprogress = function (){
      console.log (xhr.readyState); 
      }; В консоле есть цифра 3, что означает запрос в прогрессе. 

     xhr.send();    
 }

 ## С помощью кода выше уже сделали запрос и получили данные!!! 
 В тот же код сделаем изменения: создаем абзац и запишем туда полученные данные.

document.getElementById("get-data").addEventListener("click", loadData);


function loadData(){
       const xhr = new XMLHttpRequest(); 
       xhr. open("GET", "db.txt", true); 

    xhr.onload = function(){
                if(this.status ===200){
            console.log(this.responseText);
            document.querySelector(".output").innerHTML = `
            <p> 
            ${this.response} 
            </p>
            `; 
        }else {
            alert("Server error!!!")
        }
    };

    xhr.onprogress = function(){
        console.log(xhr.readyState); 
    }
    xhr.send();    
};

 Выше описано старый метод. Есть новые:  

## JSON file - обычная аннтоация литеральное объекта 
## В отличие от JS, объекты должны быть обернуты в ковычки. 